using System;
using System.Collections.Generic;
using System.Text;
using System.ComponentModel;

namespace COTES.Calc
{
    public class Calculus
    {
        /// <summary>
        /// функция расчета энтальпии по алгоритму IF-97
        /// </summary>
        /// <param name="p"></param>
        /// <param name="T"></param>
        /// <returns></returns>
        [DescriptionAttribute("Функция расчета энтальпии по алгоритму IF-97. Аргументы: 1-й p-(MPa); 2-й T-(degC);")]
        public static double Enthalpy(double p, double T)
        {

            //Делаем преобразование bar в MPa
           // p = p / 10;
            //Делаем преобразование degC в Kelvon
            T = T + 273.15;
            if (double.IsNaN(p) || double.IsNaN(T)) return double.NaN;

            //выбираем регион
            switch (regionpT(p, T))
            {
                case 1://регион 1
                    {
                        return h1_pT(p, T)/4.1868; 

                    }
                case 2://регион 2
                    {
                        return h2_pT(p, T)/ 4.1868; 

                    }
                case 3://регион 3
                    {
                        return h3_pT(p, T)/ 4.1868; 

                    }
                case 4://регион 4
                    {
                        return 0;

                    }
                case 5://регион 5
                    {
                        return h5_pT(p, T)/ 4.1868; 

                    }
                default://ошибка
                    {
                        return 0;
                    }
            }

            //   return 0;

        }

        /// <summary>
        /// Удельная теплофикационная выработка э\энергии при отпуске тепла от ОБ
        /// </summary>
        /// <param name="Q">расход пара на турбину, т\ч</param>
        /// <param name="k">2- двухкотловой, 1-однокотловой</param>
        /// <returns>возврат W МВтч/Гкал.</returns>
        [DescriptionAttribute("Удельная теплофикационная выработка э\\энергии при отпуске тепла от ОБ. Аргументы: 1-й Q-(т\\ч); 2-й K-(1 или 2-котловой);")]
        public static double ТерOb(double Q, int k)
        {
            double a, b;

            if (double.IsNaN(Q)) return double.NaN;

            if (k < 1 && k > 2) //не правельно введен режим
                return 0;
            if (k == 2) //двух котловой режим
            {
                double[] Qc ={340, 345, 350, 355, 360, 365, 370, 375, 380, 385,
                390, 395, 400, 405, 410, 415, 420, 425, 430, 435, 440, 445,
                450, 455, 460, 465, 470, 475, 480, 485, 490, 495, 500, 505, 510, 515, 520};
                double[] Wc ={0.586, 0.5872, 0.588, 0.5888 ,0.589, 0.5884, 0.5868, 0.586, 0.5854, 0.5844, 0.584, 0.5836, 0.583, 0.5824, 0.582,
            0.582, 0.582, 0.582, 0.582, 0.582, 0.582, 0.5824, 0.583, 0.5836, 0.584, 0.5836, 0.583, 0.582, 0.5808, 0.58, 0.5788,
                0.578, 0.577, 0.5764, 0.576, 0.576, 0.576};

                for (int i = 0; i < 36; i++)
                {
                    if (Q >= Qc[i] && Q <= Qc[i + 1])//между точек???
                    {
                        if (Math.Abs((Qc[i] - Q)) <= Math.Abs((Qc[i + 1] - Q)))//находим к какой точке ближе
                        {
                            return Wc[i];
                        }
                        return Wc[i + 1];
                    }
                }
            }
            if (k == 1)
            {
                //далее идет расчет по отрезкам в каждом отрезке линия y=ax+b, где a=(y1-y2)/(x1-x2) b=y2-ax2
                if (Q >= 170 && Q <= 180)//второй отрезок
                {
                    a = (0.529 - 0.532) / (170 - 180);
                    b = 0.532 - a * 180;
                    return a * Q + b;
                }
                if (Q >= 180 && Q <= 190)//третий отрезок
                {
                    a = (0.532 - 0.534) / (180 - 190);
                    b = 0.534 - a * 190;
                    return a * Q + b;
                }
                if (Q >= 190 && Q <= 210)//четвертый отрезок
                {
                    a = (0.534 - 0.54) / (190 - 210);
                    b = 0.54 - a * 210;
                    return a * Q + b;
                }
                if (Q >= 210 && Q <= 220)//пятый отрезок
                {
                    a = (0.54 - 0.542) / (210 - 220);
                    b = 0.542 - a * 220;
                    return a * Q + b;
                }
                if (Q >= 220 && Q <= 230)//шестой отрезок
                {
                    a = (0.542 - 0.545) / (220 - 230);
                    b = 0.545 - a * 230;
                    return a * Q + b;
                }
                if (Q >= 230 && Q <= 240)//седьмой отрезок
                {
                    a = (0.545 - 0.547) / (230 - 240);
                    b = 0.547 - a * 240;
                    return a * Q + b;
                }
                if (Q >= 240 && Q <= 250)//восьмой отрезок
                {
                    a = (0.547 - 0.55) / (240 - 250);
                    b = 0.55 - a * 250;
                    return a * Q + b;
                }

            }

            return 0;
        }

        /// <summary>
        /// Удельная теплофикационная выработка э\энергии при отпуске пара на ППУ
        /// </summary>
        /// <param name="Q">расход пара на турбину, т\ч</param>
        /// <param name="k">2- двухкотловой, 1-однокотловой</param>
        /// <returns>возврат W МВтч/Т.ХОВ</returns>
        [DescriptionAttribute("Удельная теплофикационная выработка э\\энергии при отпуске пара на ППУ. Аргументы: 1-й Q-(т\\ч); 2-й K-(1 или 2-котловой);")]
        public static double ParPPY(double Q, int k)
        {
            double a, b;

            if (double.IsNaN(Q)) return double.NaN;

            if (k < 1 && k > 2) //не правельно введен режим
                return 0;
            if (k == 2) //двух котловой режим
            {
                //далее идет расчет по отрезкам в каждом отрезке линия y=ax+b, где a=(y1-y2)/(x1-x2) b=y2-ax2
                if (Q >= 340 && Q <= 360)//первый отрезок
                {
                    return 0.104;
                }
                if (Q >= 360 && Q <= 370)//второй отрезок
                {
                    a = (0.104 - 0.102) / (360 - 370);
                    b = 0.102 - a * 370;
                    return a * Q + b;
                }
                if (Q >= 370 && Q <= 420)//третий отрезок
                {
                    a = (0.102 - 0.0968) / (370 - 420);
                    b = 0.0968 - a * 420;
                    return a * Q + b;
                }
                if (Q >= 420 && Q <= 440)//четвертый отрезок
                {
                    a = (0.0968 - 0.096) / (420 - 440);
                    b = 0.096 - a * 440;
                    return a * Q + b;
                }
                if (Q >= 440 && Q <= 470)//пятый отрезок
                {
                    return 0.096;
                }
                if (Q >= 470 && Q <= 480)//шестой отрезок
                {
                    a = (0.096 - 0.094) / (470 - 480);
                    b = 0.094 - a * 480;
                    return a * Q + b;
                }
                if (Q >= 480 && Q <= 500)//седьмой отрезок
                {
                    a = (0.094 - 0.0908) / (480 - 500);
                    b = 0.0908 - a * 500;
                    return a * Q + b;
                }
                if (Q >= 500 && Q <= 520)//восьмой отрезок
                {
                    a = (0.0908 - 0.09) / (500 - 520);
                    b = 0.09 - a * 520;
                    return a * Q + b;
                }
            }
            if (k == 1) //однокотловой котловой режим
            {
                a = (0.0918 - 0.093) / (170 - 250);
                b = 0.093 - a * 250;
                return a * Q + b;
            }

            return 0;
        }

        /// <summary>
        /// Поправки к Gппх котлов 1,4,5,6
        /// </summary>
        /// <param name="P">давление ППХ</param>
        /// <param name="T">температура ППХ</param>
        /// <returns>поправка</returns>
        [DescriptionAttribute("Поправки к Gппх котлов 1,4,5,6. Аргументы: 1-й P-(МПа); 2-й T-(degC);")]
        public static double Gpph(double P, double T)
        {
            double a;
            //int k = 0;

            if (double.IsNaN(P) || double.IsNaN(T)) return double.NaN;

            double[] Tpph ={ 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370 };
            double[] Ppph ={ 24.0, 24.5, 25.0, 25.5, 26.0, 26.5, 27.0, 27.5, 28.0, 28.5, 29.0, 29.5, 30.0 };
            double[,] Kpph = { 
            {0.814, 0.813, 0.812, 0.812, 0.811, 0.810, 0.809, 0.808, 0.808, 0.807, 0.806, 0.805, 0.805,0.804, 0.804, 0.803, 0.802, 0.801, 0.804, 0.800, 0.799}, 
            {0.823, 0.822, 0.821, 0.820, 0.820, 0.819, 0.818, 0.817, 0.816, 0.815, 0.815, 0.814, 0.813,0.813, 0.812, 0.812, 0.811, 0.810, 0.809, 0.808, 0.808},
            {0.831, 0.830, 0.829, 0.829, 0.828, 0.827, 0.826, 0.825, 0.825, 0.824, 0.823, 0.822, 0.822,0.821, 0.821, 0.820, 0.819, 0.818, 0.818, 0.817, 0.816},
            {0.840, 0.839, 0.838, 0.838, 0.837, 0.836, 0.835, 0.834, 0.833, 0.832, 0.832, 0.831, 0.830,0.829, 0.829, 0.828, 0.827, 0.826, 0.826, 0.825, 0.824},
            {0.849, 0.848, 0.847, 0.846, 0.845, 0.845, 0.844, 0.843, 0.842, 0.841, 0.840, 0.839, 0.838,0.838, 0.837, 0.836, 0.835, 0.834, 0.834, 0.833, 0.832},
            {0.857, 0.856, 0.855, 0.854, 0.854, 0.853, 0.852, 0.851, 0.850, 0.849, 0.849, 0.848, 0.847,0.846, 0.845, 0.845, 0.844, 0.843, 0.842, 0.841, 0.841},
            {0.865, 0.864, 0.863, 0.863, 0.862, 0.861, 0.860, 0.859, 0.859, 0.858, 0.857, 0.856, 0.855, 0.855,0.854, 0.853, 0.852, 0.851, 0.851, 0.850, 0.849},
            {0.874, 0.873, 0.872, 0.871, 0.870, 0.870, 0.869, 0.868, 0.867, 0.866, 0.866, 0.865, 0.864, 0.863,0.862, 0.862, 0.861, 0.860, 0.859, 0.858, 0.858},
            {0.882, 0.881, 0.880, 0.880, 0.879, 0.878, 0.877, 0.876, 0.876, 0.875, 0.874, 0.873, 0.872, 0.872,0.871, 0.870, 0.869, 0.868, 0.868, 0.867, 0.866},
            {0.891, 0.890, 0.889, 0.888, 0.887, 0.886, 0.885, 0.885, 0.884, 0.883, 0.882, 0.881, 0.880, 0.880,0.879, 0.878, 0.877, 0.876, 0.876, 0.875, 0.874},
            {0.899, 0.898, 0.897, 0.896, 0.895, 0.895, 0.894, 0.893, 0.892, 0.891, 0.890, 0.889, 0.888, 0.888,0.887, 0.886, 0.885, 0.884, 0.884, 0.883, 0.882},
            {0.907, 0.906, 0.905, 0.904, 0.903, 0.903, 0.902, 0.901, 0.900, 0.899, 0.898, 0.897, 0.896, 0.895,0.895, 0.894, 0.893, 0.892, 0.891, 0.890, 0.890},
            {0.915, 0.914, 0.913, 0.912, 0.911, 0.911, 0.910, 0.909, 0.908, 0.907, 0.906, 0.905, 0.904, 0.903,0.902, 0.902, 0.901, 0.900, 0.899, 0.898, 0.897}};


            for (int i = 0; i < 13; i++)
            {
                if (P >= Ppph[i] && P < Ppph[i + 1])//между точек???
                {
                    for (int j = 0; j < 21; j++)
                    {
                        if (T >= Tpph[j] && T < Tpph[j + 1])//между точек???
                        {

                            a = Kpph[i, j] + (Kpph[i + 1, j] - Kpph[i, j]) * Math.Abs((Ppph[i] - P) / 0.5);
                            /*
                            //находим к какой точке ближе
                            if (Math.Abs((Ppph[i] - P)) <= Math.Abs((Ppph[i + 1] - P)))
                            {
                                //k = i;
                                //рассчитываем процент
                                a = Kpph[i, j] * (Math.Abs((Ppph[i] - P)) / Ppph[i] + 1.0);
                            }
                            else
                            {
                               // k = i + 1;
                                //рассчитываем процент
                                a = Kpph[i + 1, j] * (1.0-Math.Abs((Ppph[i + 1] - P)) / Ppph[i]);
                            }

                            */
                            return a;
                        }
                    }
                }
            }
            return 0;
        }

        /// <summary>
        /// 2.50 Харатеристика конденсатора 100-КСЦ-2
        /// </summary>
        /// <param name="P">давление ППХ</param>
        /// <param name="T">температура ППХ</param>
        /// <returns>поправка</returns>
        [DescriptionAttribute("2.50 Харатеристика конденсатора 100-КСЦ-2. Аргументы: 1-й P-(МПа); 2-й T-(degC);")]
        public static double P2(double P, double T)
        {
            double a;
            //int k = 0;

            if (double.IsNaN(P) || double.IsNaN(T)) return double.NaN;

            double[] Tpph ={ 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370 };
            double[] Ppph ={ 24.0, 24.5, 25.0, 25.5, 26.0, 26.5, 27.0, 27.5, 28.0, 28.5, 29.0, 29.5, 30.0 };
            double[,] Kpph = { 
            {0.814, 0.813, 0.812, 0.812, 0.811, 0.810, 0.809, 0.808, 0.808, 0.807, 0.806, 0.805, 0.805,0.804, 0.804, 0.803, 0.802, 0.801, 0.804, 0.800, 0.799}, 
            {0.823, 0.822, 0.821, 0.820, 0.820, 0.819, 0.818, 0.817, 0.816, 0.815, 0.815, 0.814, 0.813,0.813, 0.812, 0.812, 0.811, 0.810, 0.809, 0.808, 0.808},
            {0.831, 0.830, 0.829, 0.829, 0.828, 0.827, 0.826, 0.825, 0.825, 0.824, 0.823, 0.822, 0.822,0.821, 0.821, 0.820, 0.819, 0.818, 0.818, 0.817, 0.816},
            {0.840, 0.839, 0.838, 0.838, 0.837, 0.836, 0.835, 0.834, 0.833, 0.832, 0.832, 0.831, 0.830,0.829, 0.829, 0.828, 0.827, 0.826, 0.826, 0.825, 0.824},
            {0.849, 0.848, 0.847, 0.846, 0.845, 0.845, 0.844, 0.843, 0.842, 0.841, 0.840, 0.839, 0.838,0.838, 0.837, 0.836, 0.835, 0.834, 0.834, 0.833, 0.832},
            {0.857, 0.856, 0.855, 0.854, 0.854, 0.853, 0.852, 0.851, 0.850, 0.849, 0.849, 0.848, 0.847,0.846, 0.845, 0.845, 0.844, 0.843, 0.842, 0.841, 0.841},
            {0.865, 0.864, 0.863, 0.863, 0.862, 0.861, 0.860, 0.859, 0.859, 0.858, 0.857, 0.856, 0.855, 0.855,0.854, 0.853, 0.852, 0.851, 0.851, 0.850, 0.849},
            {0.874, 0.873, 0.872, 0.871, 0.870, 0.870, 0.869, 0.868, 0.867, 0.866, 0.866, 0.865, 0.864, 0.863,0.862, 0.862, 0.861, 0.860, 0.859, 0.858, 0.858},
            {0.882, 0.881, 0.880, 0.880, 0.879, 0.878, 0.877, 0.876, 0.876, 0.875, 0.874, 0.873, 0.872, 0.872,0.871, 0.870, 0.869, 0.868, 0.868, 0.867, 0.866},
            {0.891, 0.890, 0.889, 0.888, 0.887, 0.886, 0.885, 0.885, 0.884, 0.883, 0.882, 0.881, 0.880, 0.880,0.879, 0.878, 0.877, 0.876, 0.876, 0.875, 0.874},
            {0.899, 0.898, 0.897, 0.896, 0.895, 0.895, 0.894, 0.893, 0.892, 0.891, 0.890, 0.889, 0.888, 0.888,0.887, 0.886, 0.885, 0.884, 0.884, 0.883, 0.882},
            {0.907, 0.906, 0.905, 0.904, 0.903, 0.903, 0.902, 0.901, 0.900, 0.899, 0.898, 0.897, 0.896, 0.895,0.895, 0.894, 0.893, 0.892, 0.891, 0.890, 0.890},
            {0.915, 0.914, 0.913, 0.912, 0.911, 0.911, 0.910, 0.909, 0.908, 0.907, 0.906, 0.905, 0.904, 0.903,0.902, 0.902, 0.901, 0.900, 0.899, 0.898, 0.897}};


            for (int i = 0; i < 13; i++)
            {
                if (P >= Ppph[i] && P < Ppph[i + 1])//между точек???
                {
                    for (int j = 0; j < 21; j++)
                    {
                        if (T >= Tpph[j] && T < Tpph[j + 1])//между точек???
                        {

                            a = Kpph[i, j] + (Kpph[i + 1, j] - Kpph[i, j]) * Math.Abs((Ppph[i] - P) / 0.5);
                            /*
                            //находим к какой точке ближе
                            if (Math.Abs((Ppph[i] - P)) <= Math.Abs((Ppph[i + 1] - P)))
                            {
                                //k = i;
                                //рассчитываем процент
                                a = Kpph[i, j] * (Math.Abs((Ppph[i] - P)) / Ppph[i] + 1.0);
                            }
                            else
                            {
                               // k = i + 1;
                                //рассчитываем процент
                                a = Kpph[i + 1, j] * (1.0-Math.Abs((Ppph[i + 1] - P)) / Ppph[i]);
                            }

                            */
                            return a;
                        }
                    }
                }
            }
            return 0;
        }


        //***********************************************************************************************************
        //Функция для выбора региона
        //'***********************************************************************************************************
        private static int regionpT(double p, double T)
        {
            double ps;
            int regionp = 0;
            if (T > 1073.15 && p < 10 && T < 2273.15 && p > 0.000611)
                regionp = 5;
            else if (T <= 1073.15 && T > 273.15 && p <= 100 && p > 0.000611)
            {
                if (T > 623.15)
                {
                    if (p > 348.05185628969 - 1.1671859879975 * T + 1.0192970039326E-03 * Math.Pow(T, 2))
                    {
                        regionp = 3;
                        if (T < 647.096)
                        {
                            ps = p4_T(T);
                            if (Math.Abs(p - ps) < 0.00001)
                                regionp = 4;
                        }
                    }
                    else
                    {
                        regionp = 2;
                    }
                }//
                else
                {
                    ps = p4_T(T);
                    if (Math.Abs(p - ps) < 0.00001)
                    {
                        regionp = 4;
                    }
                    else if (p > ps)
                    {
                        regionp = 1;
                    }
                    else
                    {
                        regionp = 2;
                    }

                }
            }
            //else
            return regionp;
        }
        //2.4 Функция для региона 4
        private static double p4_T(double T)
        {
            double teta, a, b, c;
            teta = T - 0.23855557567849 / (T - 650.17534844798);
            a = Math.Pow(teta, 2) + 1167.0521452767 * teta - 724213.16703206;
            b = -17.073846940092 * Math.Pow(teta, 2) + 12020.82470247 * teta - 3232555.0322333;
            c = 14.91510861353 * Math.Pow(teta, 2) - 4823.2657361591 * teta + 405113.40542057;
            return Math.Pow(2 * c / (-b + Math.Pow((Math.Pow(b, 2) - 4 * a * c), 0.5)), 4);
        }

        //функция для первого региона
        private static double h1_pT(double p, double T)
        {
            //'Release on the IAPWS Industrial Formulation 1997 for the Thermodynamic Properties of Water and Steam, September 1997
            //'5 Equations for Region 1, Section. 5.1 Basic Equation
            //'Eqution 7, Table 3, Page 6
            double tau, g_t;
            const double R = 0.461526; // 'kJ/(kg K)
            double[] I1 = {
              0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 
              2, 3, 3, 3, 4, 4, 4, 5, 8, 8, 21, 23, 29, 30, 31, 32};
            double[] J1 = {
             -2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1,
             3, 17, -4, 0, 6, -5, -2, 10, -8, -11, -6, -29, -31, -38, -39, -40, -41};
            double[] n1 = {
             0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872,
             0.15772038513228, -0.016616417199501, 8.1214629983568E-04, 2.8319080123804E-04, 
             -6.0706301565874E-04, -0.018990068218419, -0.032529748770505, -0.021841717175414,
             -5.283835796993E-05, -4.7184321073267E-04, -3.0001780793026E-04, 4.7661393906987E-05, 
             -4.4141845330846E-06, -7.2694996297594E-16, -3.1679644845054E-05, -2.8270797985312E-06, 
             -8.5205128120103E-10, -2.2425281908E-06, -6.5171222895601E-07, -1.4341729937924E-13, 
             -4.0516996860117E-07, -1.2734301741641E-09, -1.7424871230634E-10, -6.8762131295531E-19,
             1.4478307828521E-20, 2.6335781662795E-23, -1.1947622640071E-23, 1.8228094581404E-24, 
             -9.3537087292458E-26};

            p = p / 16.53;
            tau = 1386 / T;
            g_t = 0;
            for (int i = 0; i < 33; i++)
            {
                g_t = g_t + (n1[i] * Math.Pow((7.1 - p), I1[i]) * J1[i] * Math.Pow((tau - 1.222), (J1[i] - 1)));
            }

            return R * T * tau * g_t;
        }

        private static double h2_pT(double p, double T)
        {
            //'Release on the IAPWS Industrial Formulation 1997 for the Thermodynamic Properties of Water and Steam, September 1997
            //'6 Equations for Region 2, Section. 6.1 Basic Equation
            //'Table 11 and 12, Page 14 and 15
            double tau, g0_tau, gr_tau;
            const double R = 0.461526; //'kJ/(kg K)
            double[] J0 = { 0, 1, -5, -4, -3, -2, -1, 2, 3 };
            double[] n0 = {-9.6927686500217, 10.086655968018, -0.005608791128302, 0.071452738081455, 
                 -0.40710498223928, 1.4240819171444, -4.383951131945, -0.28408632460772, 
                 0.021268463753307};
            double[] Ir = {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 
                 4, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10, 16, 16, 18, 20, 
                 20, 20, 21, 22, 23, 24, 24, 24};
            double[] Jr = {0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35, 1, 2, 3, 7, 3, 
                 16, 35, 0, 11, 25, 8, 36, 13, 4, 10, 14, 29, 50, 57, 20, 35, 48, 21, 
                 53, 39, 26, 40, 58};
            double[] nr = {-1.7731742473213E-03, -0.017834862292358, -0.045996013696365, 
                 -0.057581259083432, -0.05032527872793, -3.3032641670203E-05, 
                   -1.8948987516315E-04, -3.9392777243355E-03, -0.043797295650573, 
                   -2.6674547914087E-05, 2.0481737692309E-08, 4.3870667284435E-07, 
                   -3.227767723857E-05, -1.5033924542148E-03, -0.040668253562649, 
                   -7.8847309559367E-10, 1.2790717852285E-08, 4.8225372718507E-07, 
                    2.2922076337661E-06, -1.6714766451061E-11, -2.1171472321355E-03, 
                 -23.895741934104, -5.905956432427E-18, -1.2621808899101E-06, -0.038946842435739,
                   1.1256211360459E-11, -8.2311340897998, 1.9809712802088E-08, 1.0406965210174E-19,
                   -1.0234747095929E-13, -1.0018179379511E-09, -8.0882908646985E-11, 0.10693031879409, 
                    -0.33662250574171, 8.9185845355421E-25, 3.0629316876232E-13, -4.2002467698208E-06, 
                   -5.9056029685639E-26, 3.7826947613457E-06, -1.2768608934681E-15, 7.3087610595061E-29,
                    5.5414715350778E-17, -9.436970724121E-07};
            tau = 540 / T;
            g0_tau = 0;
            for (int i = 0; i <= 8; i++)
            {
                g0_tau = g0_tau + n0[i] * J0[i] * Math.Pow(tau, (J0[i] - 1));
            }
            gr_tau = 0;
            for (int i = 0; i <= 42; i++)
            {
                gr_tau = gr_tau + nr[i] * Math.Pow(p, Ir[i]) * Jr[i] * Math.Pow((tau - 0.5), (Jr[i] - 1));

            }
            return R * T * tau * (g0_tau + gr_tau);
        }

        private static double h3_pT(double p, double T)
        {
            //  'Not avalible with IF 97
            //  'Solve function T3_ph-T=0 with half interval method.
            double Ts, Low_Bound, High_Bound;
            double hs = 0;
            //   'ver2.6 Start corrected bug
            if (p < 22.06395)  // 'Bellow tripple point
            {
                Ts = T4_p(p);    //'Saturation temperature

                if (T <= Ts)  //'Liquid side
                {
                    High_Bound = h4L_p(p); //'Max h дr liauid h.
                    Low_Bound = h1_pT(p, 623.15);
                }
                else
                {
                    Low_Bound = h4V_p(p); /// 'Min h дr Vapour h.
                    High_Bound = h2_pT(p, B23T_p(p));
                }
            }
            else                  //'Above tripple point. R3 from R2 till R3.
            {
                Low_Bound = h1_pT(p, 623.15);
                High_Bound = h2_pT(p, B23T_p(p));
            }
            //'ver2.6 End corrected bug
            Ts = T + 1;
            while (Math.Abs(T - Ts) > 0.000001)
            {
                hs = (Low_Bound + High_Bound) / 2;
                Ts = T3_ph(p, hs);
                if (Ts > T)
                    High_Bound = hs;
                else
                    Low_Bound = hs;
            }
            return hs;
        }
        
        private static double B23T_p(double p)
        {
            //'Release on the IAPWS Industrial Formulation 1997 for the Thermodynamic Properties of Water and Steam/
            //'1997
            //'Section 4 Auxiliary Equation for the Boundary between Regions 2 and 3
            //'Eq 6, Page 6
            return 572.54459862746 + Math.Pow(((p - 13.91883977887) / 1.0192970039326E-03), 0.5);
        }

        private static double T4_p(double p)
        {
            //  'Release on the IAPWS Industrial Formulation 1997 for the Thermodynamic Properties of Water and Steam, September 1997
            //  'Section 8.2 The Saturation-Temperature Equation
            //  'Eq 31, Page 34
            double beta, e, f, g, d;
            beta = Math.Pow(p, 0.25);
            e = Math.Pow(beta, 2) - 17.073846940092 * beta + 14.91510861353;
            f = 1167.0521452767 * Math.Pow(beta, 2) + 12020.82470247 * beta - 4823.2657361591;
            g = -724213.16703206 * Math.Pow(beta, 2) - 3232555.0322333 * beta + 405113.40542057;
            d = 2 * g / (-f - Math.Pow((Math.Pow(f, 2) - 4 * e * g), 0.5));
            return (650.17534844798 + d - Math.Pow((Math.Pow((650.17534844798 + d), 2) - 4 * (-0.23855557567849 + 650.17534844798 * d)), 0.5)) / 2;
        }

        private static double h4L_p(double p)
        {
            double Low_Bound, High_Bound, hs, ps, Ts;
            hs = ps = 0;
            if (p > 0.000611657 && p < 22.06395)
            {
                Ts = T4_p(p);
                if (p < 16.529)
                {
                    return h1_pT(p, Ts);
                }
                else
                {
                    // 'Iterate to find the the backward solution of p3sat_h
                    Low_Bound = 1670.858218;
                    High_Bound = 2087.23500164864;
                    while (Math.Abs(p - ps) > 0.00001)
                    {
                        hs = (Low_Bound + High_Bound) / 2;
                        ps = p3sat_h(hs);
                        if (ps > p)
                            High_Bound = hs;
                        else
                            Low_Bound = hs;
                    }
                    return hs;
                }
            }
            else
                return 0;
        }

        private static double h4V_p(double p)
        {
            double Low_Bound, High_Bound, hs, ps, Ts;
            hs = ps = 0;
            if (p > 0.000611657 && p < 22.06395)
            {
                Ts = T4_p(p);
                if (p < 16.529)
                    return h2_pT(p, Ts);
                else
                {
                    //'Iterate to find the the backward solution of p3sat_h
                    Low_Bound = 2087.23500164864;
                    High_Bound = 2563.592004 + 5; //'5 added to extrapolate to ensure even the border ==350°C solved.
                    while (Math.Abs(p - ps) > 0.000001)
                    {
                        hs = (Low_Bound + High_Bound) / 2;
                        ps = p3sat_h(hs);
                        if (ps < p)
                            High_Bound = hs;
                        else
                            Low_Bound = hs;
                    }
                    return hs;
                }
            }
            else
                return 0;
        }
        
        private static double T3_ph(double p, double h)
        {
            //'Revised Supplementary Release on Backward Equations for the Functions T(p,h), v(p,h) and T(p,s), v(p,s) for Region 3 of the IAPWS Industrial Formulation 1997 for the Thermodynamic Properties of Water and Steam
            //'2004
            //'Section 3.3 Backward Equations T(p,h) and v(p,h) for Subregions 3a and 3b
            //'Boundary equation, Eq 1 Page 5

            double h3ab, ps, hs, Ts;
            /*
         double  R  = 0.461526; 
         double  tc = 647.096; 
         double  pc = 22.064;
         double  rhoc = 322;
           */
            h3ab = (2014.64004206875 + 3.74696550136983 * p - 2.19921901054187E-02 * p * p + 8.7513168600995E-05 * p * p * p);
            if (h < h3ab)
            {
                //'Subregion 3a
                //'Eq 2, Table 3, Page 7
                double[] Ii = { -12, -12, -12, -12, -12, -12, -12, -12, -10, -10, -10, -8, -8, -8, -8, -5, -3, -2, -2, -2, -1, -1, 0, 0, 1, 3, 3, 4, 4, 10, 12 };
                double[] Ji = { 0, 1, 2, 6, 14, 16, 20, 22, 1, 5, 12, 0, 2, 4, 10, 2, 0, 1, 3, 4, 0, 2, 0, 1, 1, 0, 1, 0, 3, 4, 5 };
                double[] ni = {-1.33645667811215E-07, 4.55912656802978E-06, -1.46294640700979E-05, 6.3934131297008E-03, 372.783927268847, -7186.54377460447, 573494.7521034,
                               -2675693.29111439, -3.34066283302614E-05, -2.45479214069597E-02, 47.8087847764996, 7.64664131818904E-06, 1.28350627676972E-03, 1.71219081377331E-02, 
                               -8.51007304583213, -1.36513461629781E-02, -3.84460997596657E-06, 3.37423807911655E-03, -0.551624873066791, 0.72920227710747, -9.92522757376041E-03, 
                               -0.119308831407288, 0.793929190615421, 0.454270731799386, 0.20999859125991, -6.42109823904738E-03, -0.023515586860454, 2.52233108341612E-03, -7.64885133368119E-03, 
                               1.36176427574291E-02, -1.33027883575669E-02};
                ps = p / 100;
                hs = h / 2300;
                Ts = 0;
                for (int i = 0; i <= 30; i++)
                {
                    Ts = Ts + ni[i] * Math.Pow((ps + 0.24), Ii[i]) * Math.Pow((hs - 0.615), Ji[i]);
                }
                return Ts * 760;
            }
            else
            {
                //'Subregion 3b
                //'Eq 3, Table 4, Page 7,8
                double[] Ii = { -12, -12, -10, -10, -10, -10, -10, -8, -8, -8, -8, -8, -6, -6, -6, -4, -4, -3, -2, -2, -1, -1, -1, -1, -1, -1, 0, 0, 1, 3, 5, 6, 8 };
                double[] Ji = { 0, 1, 0, 1, 5, 10, 12, 0, 1, 2, 4, 10, 0, 1, 2, 0, 1, 5, 0, 4, 2, 4, 6, 10, 14, 16, 0, 2, 1, 1, 1, 1, 1 };
                double[] ni = {3.2325457364492E-05, -1.27575556587181E-04, -4.75851877356068E-04, 1.56183014181602E-03, 0.105724860113781, -85.8514221132534, 724.140095480911, 
                               2.96475810273257E-03, -5.92721983365988E-03, -1.26305422818666E-02, -0.115716196364853, 84.9000969739595, -1.08602260086615E-02, 1.54304475328851E-02, 7.50455441524466E-02, 
                               2.52520973612982E-02, -6.02507901232996E-02, -3.07622221350501, -5.74011959864879E-02, 5.03471360939849, -0.925081888584834, 3.91733882917546, -77.314600713019, 9493.08762098587, 
                               -1410437.19679409, 8491662.30819026, 0.861095729446704, 0.32334644281172, 0.873281936020439, -0.436653048526683, 0.286596714529479, -0.131778331276228, 6.76682064330275E-03};
                hs = h / 2800;
                ps = p / 100;
                Ts = 0;
                for (int i = 0; i <= 32; i++)
                    Ts = Ts + ni[i] * Math.Pow((ps + 0.298), Ii[i]) * Math.Pow((hs - 0.72), Ji[i]);
                return Ts * 860;
            }
        }
        
        //'***********************************************************************************************************
        //'*4.2 Region 3. pSat_h and pSat_s
        private static double p3sat_h(double h)
        {
            //'Revised Supplementary Release on Backward Equations for the Functions T(p,h), v(p,h) and T(p,s), v(p,s) for Region 3 of the IAPWS Industrial Formulation 1997 for the Thermodynamic Properties of Water and Steam
            //'2004
            //'Section 4 Boundary Equations psat(h) and psat(s) for the Saturation Lines of Region 3
            //'Se pictures Page 17, Eq 10, Table 17, Page 18
            double ps;
            double[] Ii = { 0, 1, 1, 1, 1, 5, 7, 8, 14, 20, 22, 24, 28, 36 };
            double[] Ji = { 0, 1, 3, 4, 36, 3, 0, 24, 16, 16, 3, 18, 8, 24 };
            double[] ni = {0.600073641753024, -9.36203654849857, 24.6590798594147, -107.014222858224,
                           -91582131580576.8, -8623.32011700662, -23.5837344740032, 2.52304969384128E+17, 
                           -3.89718771997719E+18, -3.33775713645296E+22, 35649946963.6328, -1.48547544720641E+26, 
                           3.30611514838798E+18, 8.13641294467829E+37};
            h = h / 2600;
            ps = 0;
            //For i = 0 To 13
            for (int i = 0; i <= 13; i++)
                ps = ps + ni[i] * Math.Pow((h - 1.02), Ii[i]) * Math.Pow((h - 0.608), Ji[i]);
            return ps * 22;
        }

        //'***********************************************************************************************************
        //'*2.5 Functions for region 5
        private static double h5_pT(double p, double T)
        {
            // 'Release on the IAPWS Industrial Formulation 1997 for the Thermodynamic Properties of Water and Steam, September 1997
            // 'Basic Equation for Region 5
            // 'Eq 32,33, Page 36, Tables 37-41
            double tau, gamma0_tau, gammar_tau;
            double R = 0.461526;//   'kJ/(kg K)
            double[] Ji0 = { 0, 1, -3, -2, -1, 2 };
            double[] ni0 = { -13.179983674201, 6.8540841634434, -0.024805148933466, 0.36901534980333, -3.1161318213925, -0.32961626538917 };
            double[] Iir = { 1, 1, 1, 2, 3 };
            double[] Jir = { 0, 1, 3, 9, 3 };
            double[] nir = { -1.2563183589592E-04, 2.1774678714571E-03, -0.004594282089991, -3.9724828359569E-06, 1.2919228289784E-07 };
            tau = 1000 / T;
            gamma0_tau = 0;
            for (int i = 0; i <= 5; i++)
                gamma0_tau = gamma0_tau + ni0[i] * Ji0[i] * Math.Pow(tau, (Ji0[i] - 1));

            gammar_tau = 0;
            for (int i = 0; i <= 4; i++)
                gammar_tau = gammar_tau + nir[i] * Math.Pow(p, Iir[i]) * Jir[i] * Math.Pow(tau, (Jir[i] - 1));

            return R * T * tau * (gamma0_tau + gammar_tau);
        }
    }
}