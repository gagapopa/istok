<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="d:\vs2013\team tools\static analysis tools\fxcop\Xml\CodeAnalysisReport.xsl"?>
<FxCopReport Version="12.0">
 <Targets>
  <Target Name="D:\Cloud@Mail.Ru\isbk-src\src\CommonLib\bin\Debug\COTES.ISTOK.Common.dll">
   <Modules>
    <Module Name="cotes.istok.common.dll">
     <Namespaces>
      <Namespace Name="COTES.ISTOK">
       <Types>
        <Type Name="AsyncOperation" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="Breaking">
           <Issue Name="ProvideDisposeBool" Certainty="95" Level="Error">Предоставьте перегружаемую реализацию Dispose(bool) для 'AsyncOperation' или отметьте тип как запечатанный. При вызове Dispose(false) должны очищаться только машинные ресурсы. При вызове Dispose(true) должны очищаться и управляемые, и машинные ресурсы.</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib\AsyncOperations" File="AsyncOperation.cs" Line="410">Измените 'AsyncOperation.Dispose()', чтобы он вызывал Dispose(true), затем вызывал GC.SuppressFinalize для текущего экземпляра объекта ("this" или "Me" в Visual Basic), а затем возвращал результат.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="CommonData" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#DecryptText(System.String)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="Не ликвидировать объекты несколько раз" Category="Microsoft.Usage" CheckId="CA2202" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="Tools.cs" Line="182">Объект "'cstream'" можно удалять более одного раза в методе 'CommonData.DecryptText(string)'. Чтобы избежать исключения System.ObjectDisposedException, следует вызывать метод "Dispose" для объекта только один раз.: Lines: 182</Issue>
             <Issue Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="Tools.cs" Line="182">Объект "'stream'" можно удалять более одного раза в методе 'CommonData.DecryptText(string)'. Чтобы избежать исключения System.ObjectDisposedException, следует вызывать метод "Dispose" для объекта только один раз.: Lines: 182, 183</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#EncryptText(System.Security.SecureString)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="Не ликвидировать объекты несколько раз" Category="Microsoft.Usage" CheckId="CA2202" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="Tools.cs" Line="213">Объект "'cstream'" можно удалять более одного раза в методе 'CommonData.EncryptText(SecureString)'. Чтобы избежать исключения System.ObjectDisposedException, следует вызывать метод "Dispose" для объекта только один раз.: Lines: 213</Issue>
             <Issue Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="Tools.cs" Line="213">Объект "'stream'" можно удалять более одного раза в методе 'CommonData.EncryptText(SecureString)'. Чтобы избежать исключения System.ObjectDisposedException, следует вызывать метод "Dispose" для объекта только один раз.: Lines: 213, 214</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="Interval" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#System.IComparable`1&lt;COTES.ISTOK.Interval&gt;.CompareTo(COTES.ISTOK.Interval)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="Interval.cs" Line="419">Запечатайте 'Interval' (критическое изменение, если ранее данный класс был доставлен), реализуйте метод неявно или реализуйте новый метод, который предоставляет функциональность 'IComparable&lt;Interval&gt;.CompareTo(Interval)' и видим производным классам.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="Message" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(System.DateTime,COTES.ISTOK.MessageCategory,System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="Log.cs" Line="99">'Message.Message(DateTime, MessageCategory, string)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;Message..ctor(DateTime, MessageCategory, String)&#xD;&#xA;Message.set_Text(String):Void</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="MessageByException" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(System.Exception)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="Log.cs" Line="151">'MessageByException.MessageByException(Exception)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;MessageByException..ctor(Exception)&#xD;&#xA;Message.set_Text(String):Void</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="MimeTexWrapper+NativeMethods" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#CreateGifFromEq(System.String,System.String)" Kind="Method" Static="True" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать параметр 'expr' как Юникод, установив значение CharSet.Unicode для DllImport.CharSet, либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо упаковать и передать эту строку как ANSI или зависящую от системы, укажите MarshalAs явно и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</Issue>
            </Message>
            <Message Id="1" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать параметр 'fileName' как Юникод, установив значение CharSet.Unicode для DllImport.CharSet, либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо упаковать и передать эту строку как ANSI или зависящую от системы, укажите MarshalAs явно и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetModuleHandle(System.String)" Kind="Method" Static="True" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message Id="0" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать параметр 'lpModuleName' как Юникод, установив значение CharSet.Unicode для DllImport.CharSet, либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо упаковать и передать эту строку как ANSI или зависящую от системы, укажите MarshalAs явно и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="MyDBdata" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="Breaking">
           <Issue Name="ProvideDisposeBool" Certainty="95" Level="Error">Предоставьте перегружаемую реализацию Dispose(bool) для 'MyDBdata' или отметьте тип как запечатанный. При вызове Dispose(false) должны очищаться только машинные ресурсы. При вызове Dispose(true) должны очищаться и управляемые, и машинные ресурсы.</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#CreateDatabase(COTES.ISTOK.DbDatabaseSettings)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="RethrowToPreserveStackDetails" Category="Microsoft.Usage" CheckId="CA2200" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="MyDBData.cs" Line="227">'MyDBdata.CreateDatabase(DbDatabaseSettings)' повторно порождает перехваченное исключение и явно указывает его в качестве аргумента. Используйте вместо этого "throw" без аргумента, чтобы сохранить место стека, где первоначально было вызвано исключение.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="MyDBData.cs" Line="860">Измените 'MyDBdata.Dispose()', чтобы он вызывал Dispose(true), затем вызывал GC.SuppressFinalize для текущего экземпляра объекта ("this" или "Me" в Visual Basic), а затем возвращал результат.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Exec_Function(System.Int32,System.String,COTES.ISTOK.DB_Parameters)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="Проверка запросов SQL на уязвимости безопасности" Category="Microsoft.Security" CheckId="CA2100" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="DependsOnFix">
             <Issue Name="WithNonLiterals" Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="MyDBData.cs" Line="631">Строка запроса, переданная 'OleDbCommand.CommandText.set(string)' в 'MyDBdata.Exec_Function(int, string, DB_Parameters)', может содержать следующие переменные 'Query'. Если любая из этих переменных может поступать из вводимых пользователем данных, рассмотрите возможность использования хранимой процедуры или параметризованного запроса SQL вместо сборки запроса с помощью конкатенации строк.</Issue>
             <Issue Name="WithNonLiterals" Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="MyDBData.cs" Line="616">Строка запроса, переданная 'SqlCommand.CommandText.set(string)' в 'MyDBdata.Exec_Function(int, string, DB_Parameters)', может содержать следующие переменные 'Query'. Если любая из этих переменных может поступать из вводимых пользователем данных, рассмотрите возможность использования хранимой процедуры или параметризованного запроса SQL вместо сборки запроса с помощью конкатенации строк.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ExecSQL(System.Int32,System.String,COTES.ISTOK.DB_Parameters,System.Int32)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="Проверка запросов SQL на уязвимости безопасности" Category="Microsoft.Security" CheckId="CA2100" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="DependsOnFix">
             <Issue Name="WithNonLiterals" Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="MyDBData.cs" Line="363">Строка запроса, переданная 'DbCommand.CommandText.set(string)' в 'MyDBdata.ExecSQL(int, string, DB_Parameters, int)', может содержать следующие переменные 'query'. Если любая из этих переменных может поступать из вводимых пользователем данных, рассмотрите возможность использования хранимой процедуры или параметризованного запроса SQL вместо сборки запроса с помощью конкатенации строк.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ExecSQL_toDataset(System.Int32,System.String,COTES.ISTOK.DB_Parameters)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="Проверка запросов SQL на уязвимости безопасности" Category="Microsoft.Security" CheckId="CA2100" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="DependsOnFix">
             <Issue Name="WithNonLiterals" Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="MyDBData.cs" Line="684">Строка запроса, переданная 'DbCommand.CommandText.set(string)' в 'MyDBdata.ExecSQL_toDataset(int, string, DB_Parameters)', может содержать следующие переменные 'query'. Если любая из этих переменных может поступать из вводимых пользователем данных, рассмотрите возможность использования хранимой процедуры или параметризованного запроса SQL вместо сборки запроса с помощью конкатенации строк.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ExecSQL_toReader(System.Int32,System.String,COTES.ISTOK.DB_Parameters)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="Проверка запросов SQL на уязвимости безопасности" Category="Microsoft.Security" CheckId="CA2100" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="DependsOnFix">
             <Issue Name="WithNonLiterals" Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="MyDBData.cs" Line="579">Строка запроса, переданная 'DbCommand.CommandText.set(string)' в 'MyDBdata.ExecSQL_toReader(int, string, DB_Parameters)', может содержать следующие переменные 'query'. Если любая из этих переменных может поступать из вводимых пользователем данных, рассмотрите возможность использования хранимой процедуры или параметризованного запроса SQL вместо сборки запроса с помощью конкатенации строк.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ExecSQL_toTable(System.Int32,System.String,COTES.ISTOK.DB_Parameters)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="Проверка запросов SQL на уязвимости безопасности" Category="Microsoft.Security" CheckId="CA2100" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="DependsOnFix">
             <Issue Name="WithNonLiterals" Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="MyDBData.cs" Line="445">Строка запроса, переданная 'DbCommand.CommandText.set(string)' в 'MyDBdata.ExecSQL_toTable(int, string, DB_Parameters)', может содержать следующие переменные 'query'. Если любая из этих переменных может поступать из вводимых пользователем данных, рассмотрите возможность использования хранимой процедуры или параметризованного запроса SQL вместо сборки запроса с помощью конкатенации строк.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ExecSQL_toXml(System.Int32,System.String,COTES.ISTOK.DB_Parameters,System.Xml.XmlWriter)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="Проверка запросов SQL на уязвимости безопасности" Category="Microsoft.Security" CheckId="CA2100" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="DependsOnFix">
             <Issue Name="WithNonLiterals" Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="MyDBData.cs" Line="510">Строка запроса, переданная 'DbCommand.CommandText.set(string)' в 'MyDBdata.ExecSQL_toXml(int, string, DB_Parameters, XmlWriter)', может содержать следующие переменные 'query'. Если любая из этих переменных может поступать из вводимых пользователем данных, рассмотрите возможность использования хранимой процедуры или параметризованного запроса SQL вместо сборки запроса с помощью конкатенации строк.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="NonSerializedException" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementISerializableCorrectly" Category="Microsoft.Usage" CheckId="CA2240" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
           <Issue Name="MakeOverridable" Certainty="60" Level="Error">Сделайте 'NonSerializedException'.GetObjectData виртуальным и переопределяемым.</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#.ctor(System.Exception)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib\AsyncOperations" File="AsyncOperation.cs" Line="435">'NonSerializedException.NonSerializedException(Exception)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;NonSerializedException..ctor(Exception)&#xD;&#xA;Exception.set_HelpLink(String):Void</Issue>
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib\AsyncOperations" File="AsyncOperation.cs" Line="435">'NonSerializedException.NonSerializedException(Exception)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;NonSerializedException..ctor(Exception)&#xD;&#xA;Exception.set_HelpLink(String):Void&#xD;&#xA;Exception.set_Source(String):Void</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ParameterRegistrator" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#GetLastValue" Kind="Event" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DeclareEventHandlersCorrectly" Category="Microsoft.Design" CheckId="CA1009" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="Breaking">
             <Issue Name="First" Certainty="95" Level="Error">Объявите первый параметр для 'GetLastValueDelegate' как объект с именем "sender".</Issue>
             <Issue Name="Return" Certainty="95" Level="Error">Измените 'GetLastValueDelegate' для возврата значения типа void.</Issue>
             <Issue Name="Second" Certainty="95" Level="Error">Объявите второй параметр для 'GetLastValueDelegate' как EventArgs или экземпляр типа, расширяющего EventArgs, и присвойте ему имя "e".</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ParamValueItem" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(COTES.ISTOK.ArgumentsValues,System.DateTime,COTES.ISTOK.Quality,System.Double)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib\Value" File="ParamValueItem.cs" Line="47">'ParamValueItem.ParamValueItem(ArgumentsValues, DateTime, Quality, double)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;ParamValueItem..ctor(ArgumentsValues, DateTime, Quality, Double)&#xD;&#xA;ParamValueItem.set_Arguments(ArgumentsValues):Void</Issue>
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib\Value" File="ParamValueItem.cs" Line="47">'ParamValueItem.ParamValueItem(ArgumentsValues, DateTime, Quality, double)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;ParamValueItem..ctor(ArgumentsValues, DateTime, Quality, Double)&#xD;&#xA;ParamValueItem.set_ChangeTime(DateTime):Void</Issue>
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib\Value" File="ParamValueItem.cs" Line="47">'ParamValueItem.ParamValueItem(ArgumentsValues, DateTime, Quality, double)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;ParamValueItem..ctor(ArgumentsValues, DateTime, Quality, Double)&#xD;&#xA;ParamValueItem.set_Quality(Quality):Void</Issue>
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib\Value" File="ParamValueItem.cs" Line="47">'ParamValueItem.ParamValueItem(ArgumentsValues, DateTime, Quality, double)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;ParamValueItem..ctor(ArgumentsValues, DateTime, Quality, Double)&#xD;&#xA;ParamValueItem.set_Time(DateTime):Void</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(COTES.ISTOK.ParamValueItem)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib\Value" File="ParamValueItem.cs" Line="60">'ParamValueItem.ParamValueItem(ParamValueItem)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;ParamValueItem..ctor(ParamValueItem)&#xD;&#xA;ParamValueItem.set_Arguments(ArgumentsValues):Void</Issue>
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib\Value" File="ParamValueItem.cs" Line="60">'ParamValueItem.ParamValueItem(ParamValueItem)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;ParamValueItem..ctor(ParamValueItem)&#xD;&#xA;ParamValueItem.set_ChangeTime(DateTime):Void</Issue>
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib\Value" File="ParamValueItem.cs" Line="60">'ParamValueItem.ParamValueItem(ParamValueItem)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;ParamValueItem..ctor(ParamValueItem)&#xD;&#xA;ParamValueItem.set_Quality(Quality):Void</Issue>
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib\Value" File="ParamValueItem.cs" Line="60">'ParamValueItem.ParamValueItem(ParamValueItem)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;ParamValueItem..ctor(ParamValueItem)&#xD;&#xA;ParamValueItem.set_Time(DateTime):Void</Issue>
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib\Value" File="ParamValueItem.cs" Line="60">'ParamValueItem.ParamValueItem(ParamValueItem)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;ParamValueItem..ctor(ParamValueItem)&#xD;&#xA;ParamValueItem.set_Value(Double):Void</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="RevisedStorage`1" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#System.Collections.Generic.IEnumerable`1&lt;COTES.ISTOK.RevisionInfo&gt;.GetEnumerator()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error">Запечатайте 'RevisedStorage&lt;T&gt;' (критическое изменение, если ранее данный класс был доставлен), реализуйте метод неявно или реализуйте новый метод, который предоставляет функциональность 'IEnumerable&lt;RevisionInfo&gt;.GetEnumerator()' и видим производным классам.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#System.Collections.IEnumerable.GetEnumerator()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib\Revision" File="RevisedStorage.cs" Line="138">Запечатайте 'RevisedStorage&lt;T&gt;' (критическое изменение, если ранее данный класс был доставлен), реализуйте метод неявно или реализуйте новый метод, который предоставляет функциональность 'IEnumerable.GetEnumerator()' и видим производным классам.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="UltimateZipper" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Pack(COTES.ISTOK.Package)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="Не ликвидировать объекты несколько раз" Category="Microsoft.Usage" CheckId="CA2202" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="BaseClasses.cs" Line="221">Объект "'memStream'" можно удалять более одного раза в методе 'UltimateZipper.Pack(Package)'. Чтобы избежать исключения System.ObjectDisposedException, следует вызывать метод "Dispose" для объекта только один раз.: Lines: 221, 231</Issue>
             <Issue Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="BaseClasses.cs" Line="221">Объект "'zipStream'" можно удалять более одного раза в методе 'UltimateZipper.Pack(Package)'. Чтобы избежать исключения System.ObjectDisposedException, следует вызывать метод "Dispose" для объекта только один раз.: Lines: 221</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Unpack(COTES.ISTOK.PackedPackage)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="Не ликвидировать объекты несколько раз" Category="Microsoft.Usage" CheckId="CA2202" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="BaseClasses.cs" Line="294">Объект "'m'" можно удалять более одного раза в методе 'UltimateZipper.Unpack(PackedPackage)'. Чтобы избежать исключения System.ObjectDisposedException, следует вызывать метод "Dispose" для объекта только один раз.: Lines: 294</Issue>
             <Issue Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="BaseClasses.cs" Line="322">Объект "'mem'" можно удалять более одного раза в методе 'UltimateZipper.Unpack(PackedPackage)'. Чтобы избежать исключения System.ObjectDisposedException, следует вызывать метод "Dispose" для объекта только один раз.: Lines: 322</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="WindowsServiceHelper" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#ChangeServiceConfig(System.IntPtr,System.Int32,System.Int32,System.Int32,System.String,System.String,System.IntPtr,System.String,System.String,System.String,System.String)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">Так как метод является методом P/Invoke, 'WindowsServiceHelper.ChangeServiceConfig(IntPtr, int, int, int, string, string, IntPtr, string, string, string, string)' должен быть определен в классе с именем NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</Issue>
            </Message>
            <Message Id="10" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать параметр 'lpDisplayName' как Юникод, установив значение CharSet.Unicode для DllImport.CharSet, либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо упаковать и передать эту строку как ANSI или зависящую от системы, укажите MarshalAs явно и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</Issue>
            </Message>
            <Message Id="4" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать параметр 'lpBinaryPathName' как Юникод, установив значение CharSet.Unicode для DllImport.CharSet, либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо упаковать и передать эту строку как ANSI или зависящую от системы, укажите MarshalAs явно и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</Issue>
            </Message>
            <Message Id="5" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать параметр 'lpLoadOrderGroup' как Юникод, установив значение CharSet.Unicode для DllImport.CharSet, либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо упаковать и передать эту строку как ANSI или зависящую от системы, укажите MarshalAs явно и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</Issue>
            </Message>
            <Message Id="7" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать параметр 'lpDependencies' как Юникод, установив значение CharSet.Unicode для DllImport.CharSet, либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо упаковать и передать эту строку как ANSI или зависящую от системы, укажите MarshalAs явно и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</Issue>
            </Message>
            <Message Id="8" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать параметр 'lpServiceStartName' как Юникод, установив значение CharSet.Unicode для DllImport.CharSet, либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо упаковать и передать эту строку как ANSI или зависящую от системы, укажите MarshalAs явно и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</Issue>
            </Message>
            <Message Id="9" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать параметр 'lpPassword' как Юникод, установив значение CharSet.Unicode для DllImport.CharSet, либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо упаковать и передать эту строку как ANSI или зависящую от системы, укажите MarshalAs явно и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ChangeServiceConfig2(System.IntPtr,System.Int32,System.IntPtr)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">Так как метод является методом P/Invoke, 'WindowsServiceHelper.ChangeServiceConfig2(IntPtr, int, IntPtr)' должен быть определен в классе с именем NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CloseServiceHandle(System.IntPtr)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">Так как метод является методом P/Invoke, 'WindowsServiceHelper.CloseServiceHandle(IntPtr)' должен быть определен в классе с именем NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#OpenSCManager(System.IntPtr,System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">Так как метод является методом P/Invoke, 'WindowsServiceHelper.OpenSCManager(IntPtr, IntPtr, int)' должен быть определен в классе с именем NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#OpenService(System.IntPtr,System.String,System.Int32)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">Так как метод является методом P/Invoke, 'WindowsServiceHelper.OpenService(IntPtr, string, int)' должен быть определен в классе с именем NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</Issue>
            </Message>
            <Message Id="1" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать параметр 'lpServiceName' как Юникод, установив значение CharSet.Unicode для DllImport.CharSet, либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо упаковать и передать эту строку как ANSI или зависящую от системы, укажите MarshalAs явно и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#QueryServiceConfig(System.IntPtr,System.IntPtr,System.Int32,System.Int32&amp;)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">Так как метод является методом P/Invoke, 'WindowsServiceHelper.QueryServiceConfig(IntPtr, IntPtr, int, out int)' должен быть определен в классе с именем NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="COTES.ISTOK.Calc">
       <Types>
        <Type Name="CalcMessage" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(COTES.ISTOK.Calc.CalcMessage)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:55:32Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\CommonLib" File="CalcMessage.cs" Line="261">'CalcMessage.CalcMessage(CalcMessage)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;CalcMessage..ctor(CalcMessage)&#xD;&#xA;Message.set_Text(String):Void</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
     </Namespaces>
    </Module>
   </Modules>
  </Target>
 </Targets>
 <Rules>
  <Rule TypeName="DeclareEventHandlersCorrectly" Category="Microsoft.Design" CheckId="CA1009">
   <Name>Правильно объявите обработчики событий</Name>
   <Description>По соглашению для событий .NET предусмотрены два параметра, определяющие источник события и данные события. Сигнатуры обработчиков событий должны иметь следующую форму: void MyEventHandler(object sender, EventArgs e). Параметр "sender" всегда имеет тип System.Object, даже если есть возможность использовать более конкретный тип. Параметр "e" всегда имеет тип System.EventArgs. События, не предоставляющие данных о себе, должны использовать тип делегата System.EventHandler. Обработчики событий возвращают значение void, благодаря чему они могут отправлять каждое событие множеству целевых методов. Любое значение, возвращенное целевым объектом, будет утеряно после первого вызова.</Description>
   <Resolution Name="First">Объявите первый параметр для {0} как объект с именем "sender".</Resolution>
   <Resolution Name="Return">Измените {0} для возврата значения типа void.</Resolution>
   <Resolution Name="Second">Объявите второй параметр для {0} как EventArgs или экземпляр типа, расширяющего EventArgs, и присвойте ему имя "e".</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182133.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="12.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214">
   <Name>Не вызывайте переопределяемые методы в конструкторах</Name>
   <Description>Виртуальные методы, определенные в классе, не следует вызывать из конструкторов. Если производный класс переопределил метод, будет вызвана версия производного класса (до вызова конструктора производного класса).</Description>
   <Resolution Name="Default">{0} содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: {1}</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182331.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalWarning</MessageLevel>
   <File Name="usagerules.dll" Version="12.0.0.0" />
  </Rule>
  <Rule TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063">
   <Name>Правильно реализуйте IDisposable</Name>
   <Description>Во всех типах IDisposable шаблон Dispose должен быть реализован правильно.</Description>
   <Resolution Name="DisposeImplementation">Измените {0}, чтобы он вызывал Dispose(true), затем вызывал GC.SuppressFinalize для текущего экземпляра объекта ("this" или "Me" в Visual Basic), а затем возвращал результат.</Resolution>
   <Resolution Name="ProvideDisposeBool">Предоставьте перегружаемую реализацию Dispose(bool) для {0} или отметьте тип как запечатанный. При вызове Dispose(false) должны очищаться только машинные ресурсы. При вызове Dispose(true) должны очищаться и управляемые, и машинные ресурсы.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms244737.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="12.0.0.0" />
  </Rule>
  <Rule TypeName="ImplementISerializableCorrectly" Category="Microsoft.Usage" CheckId="CA2240">
   <Name>Правильно реализуйте ISerializable</Name>
   <Description>Если тип допускает присваивание к ISerializable, он должен реализовать GetObjectData. Для незапечатанных типов производные типы должны иметь возможность вызывать и переопределять метод GetObjectData.</Description>
   <Resolution Name="MakeOverridable">Сделайте {0}.GetObjectData виртуальным и переопределяемым.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182342.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="60">Error</MessageLevel>
   <File Name="usagerules.dll" Version="12.0.0.0" />
  </Rule>
  <Rule TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033">
   <Name>Методы интерфейса должны быть доступны для вызова дочерним типам</Name>
   <Description>Явные реализации методов определены с режимом доступа private. Классы, производные от классов с явной реализацией методов и выбравшие их повторное объявление на своем уровне, не смогут вызывать реализации базового класса, если базовый класс не предоставит альтернативный метод с соответствующим режимом доступа. В случае переопределения метода базового класса, который был скрыт, благодаря явной реализации интерфейса, производный класс, чтобы вызвать реализацию базового класса, должен выполнить приведение базового указателя к соответствующему интерфейсу. Однако при вызове при помощи данной ссылки фактически будет вызываться реализация производного класса, что приведет к рекурсии и, в конце концов, к переполнению стека.</Description>
   <Resolution Name="Default">Запечатайте {0} (критическое изменение, если ранее данный класс был доставлен), реализуйте метод неявно или реализуйте новый метод, который предоставляет функциональность {1} и видим производным классам.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182153.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="12.0.0.0" />
  </Rule>
  <Rule TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060">
   <Name>Переместите методы P/Invoke в класс NativeMethods</Name>
   <Description>В этом типе содержатся члены с атрибутом DllImport. Члены с атрибутом DllImport должны содержаться в классах с именем NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</Description>
   <Resolution Name="Default">Так как метод является методом P/Invoke, {0} должен быть определен в классе с именем NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182161.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalWarning</MessageLevel>
   <File Name="designrules.dll" Version="12.0.0.0" />
  </Rule>
  <Rule TypeName="RethrowToPreserveStackDetails" Category="Microsoft.Usage" CheckId="CA2200">
   <Name>Повторно порождайте исключения для сохранения сведений стека</Name>
   <Description>Используйте инструкцию IL rethrow для сохранения исходных сведений стека при повторном вызове перехваченного исключения.</Description>
   <Resolution Name="Default">{0} повторно порождает перехваченное исключение и явно указывает его в качестве аргумента. Используйте вместо этого "throw" без аргумента, чтобы сохранить место стека, где первоначально было вызвано исключение.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182363.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="usagerules.dll" Version="12.0.0.0" />
  </Rule>
  <Rule TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101">
   <Name>Укажите тип маршалинга для строковых аргументов P/Invoke</Name>
   <Description>При маршалинге строк в формате ANSI (или как Auto в Win9x) некоторые знаки могут быть изменены. Если включено сопоставление путем автоматического подбора, строки, которые отображаются в формате Юникод по-другому, будут маршалированы в идентичные ANSI-строки, что может привести к неверным решениям по обеспечению безопасности. Отключение сопоставления путем автоматического подбора уменьшит возможность этой угрозы, так как все знаки, не имеющие эквивалента, будут заменены знаком "?". Также следует отметить, что CharSet.Ansi является настройкой по умолчанию для маршалинга всех строк. Маршалинг в формате Юникод следует указывать явно, либо как значение CharSet в DllImport или StructLayout, либо как атрибут MarshalAs с типом Unicode (или зависящим от системы) UnmanagedType.</Description>
   <Resolution Name="ParameterImplicitAnsi">Чтобы уменьшить угрозу безопасности, следует маршалировать параметр {0} как Юникод, установив значение CharSet.Unicode для DllImport.CharSet, либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо упаковать и передать эту строку как ANSI или зависящую от системы, укажите MarshalAs явно и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182319.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Error</MessageLevel>
   <File Name="globalizationrules.dll" Version="12.0.0.0" />
  </Rule>
  <Rule TypeName="Не ликвидировать объекты несколько раз" Category="Microsoft.Usage" CheckId="CA2202">
   <Name>Не ликвидировать объекты несколько раз</Name>
   <Description>Правильно реализованный метод Dispose может вызываться неоднократно без создания исключения. Однако такой гарантии нет, и чтобы предотвратить создание System.ObjectDisposedException, не следует вызывать метод Dispose для объекта более одного раза.</Description>
   <Resolution Name="Default">Объект "{0}" можно удалять более одного раза в методе {1}. Чтобы избежать исключения System.ObjectDisposedException, следует вызывать метод "Dispose" для объекта только один раз.: Lines: 213</Resolution>
   <Owner>RuleOwner</Owner>
   <Url>http://msdn.microsoft.com/library/ms182334.aspx</Url>
   <Email />
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="dataflowrules.dll" Version="12.0.0.0" />
  </Rule>
  <Rule TypeName="Проверка запросов SQL на уязвимости безопасности" Category="Microsoft.Security" CheckId="CA2100">
   <Name>Проверка запросов SQL на уязвимости безопасности</Name>
   <Description>Командная строка SQL, создаваемая на основе введенных пользователем данных, уязвима к атакам типа "инъекция SQL". Microsoft SQL Server и другие серверы баз данных поддерживают хранимые процедуры и параметризованные SQL-запросы, что снижает риск атак путем внедрения.</Description>
   <Resolution Name="WithNonLiterals">Строка запроса, переданная {0} в {1}, может содержать следующие переменные {2}. Если любая из этих переменных может поступать из вводимых пользователем данных, рассмотрите возможность использования хранимой процедуры или параметризованного запроса SQL вместо сборки запроса с помощью конкатенации строк.</Resolution>
   <Owner>RuleOwner</Owner>
   <Url>http://msdn.microsoft.com/library/ms182310.aspx</Url>
   <Email />
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="dataflowrules.dll" Version="12.0.0.0" />
  </Rule>
 </Rules>
 <Localized>
  <String Key="Category">Категория</String>
  <String Key="Certainty">Достоверность</String>
  <String Key="CollapseAll">Свернуть все</String>
  <String Key="CheckId">ИД проверки</String>
  <String Key="Error">Ошибка</String>
  <String Key="Errors">ошибки</String>
  <String Key="ExpandAll">Развернуть все</String>
  <String Key="Help">Справка</String>
  <String Key="Line">Строка</String>
  <String Key="Messages">сообщения</String>
  <String Key="LocationNotStoredInPdb">[расположение не сохранено в PDB]</String>
  <String Key="Project">Проект</String>
  <String Key="Resolution">Разрешение</String>
  <String Key="Rule">Правило</String>
  <String Key="RuleFile">Файл правил</String>
  <String Key="RuleDescription">Описание правила</String>
  <String Key="Source">Источник</String>
  <String Key="Status">Состояние</String>
  <String Key="Target">Цель</String>
  <String Key="Warning">Предупреждение</String>
  <String Key="Warnings">предупреждения</String>
  <String Key="ReportTitle">Отчет по анализу кода</String>
 </Localized>
</FxCopReport>
