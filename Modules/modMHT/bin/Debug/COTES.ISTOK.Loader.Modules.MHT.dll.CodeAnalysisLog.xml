<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="d:\vs2013\team tools\static analysis tools\fxcop\Xml\CodeAnalysisReport.xsl"?>
<FxCopReport Version="12.0">
 <Targets>
  <Target Name="D:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\bin\Debug\COTES.ISTOK.Loader.Modules.MHT.dll">
   <Modules>
    <Module Name="cotes.istok.loader.modules.mht.dll">
     <Namespaces>
      <Namespace Name="CommonFunctions">
       <Types>
        <Type Name="UNCAccess" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#NetUseAdd(System.String,System.UInt32,CommonFunctions.UNCAccess+USE_INFO_2&amp;,System.UInt32&amp;)" Kind="Method" Static="True" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">Так как метод является методом P/Invoke, 'UNCAccess.NetUseAdd(string, uint, ref UNCAccess.USE_INFO_2, out uint)' должен быть определен в классе с именем NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#NetUseDel(System.String,System.String,System.UInt32)" Kind="Method" Static="True" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">Так как метод является методом P/Invoke, 'UNCAccess.NetUseDel(string, string, uint)' должен быть определен в классе с именем NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="HtmlAgilityPack">
       <Types>
        <Type Name="EncodingFoundException" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Messages>
          <Message TypeName="MarkISerializableTypesWithSerializable" Category="Microsoft.Usage" CheckId="CA2237" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
           <Issue Certainty="95" Level="Error">Добавьте [Serializable] к 'EncodingFoundException', так как этот тип реализует ISerializable.</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="HtmlAttributeCollection" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#System.Collections.Generic.ICollection`1&lt;HtmlAgilityPack.HtmlAttribute&gt;.Clear()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlAttributeCollection.cs" Line="90">Запечатайте 'HtmlAttributeCollection' (критическое изменение, если ранее данный класс был доставлен), реализуйте метод неявно или реализуйте новый метод, который предоставляет функциональность 'ICollection&lt;HtmlAttribute&gt;.Clear()' и видим производным классам.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#System.Collections.Generic.IEnumerable`1&lt;HtmlAgilityPack.HtmlAttribute&gt;.GetEnumerator()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlAttributeCollection.cs" Line="119">Запечатайте 'HtmlAttributeCollection' (критическое изменение, если ранее данный класс был доставлен), реализуйте метод неявно или реализуйте новый метод, который предоставляет функциональность 'IEnumerable&lt;HtmlAttribute&gt;.GetEnumerator()' и видим производным классам.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#System.Collections.IEnumerable.GetEnumerator()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlAttributeCollection.cs" Line="128">Запечатайте 'HtmlAttributeCollection' (критическое изменение, если ранее данный класс был доставлен), реализуйте метод неявно или реализуйте новый метод, который предоставляет функциональность 'IEnumerable.GetEnumerator()' и видим производным классам.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="HtmlNode" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Id" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_Id()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message TypeName="DoNotRaiseExceptionsInUnexpectedLocations" Category="Microsoft.Design" CheckId="CA1065" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="Breaking">
               <Issue Name="PropertyGetter" Certainty="90" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNode.cs" Line="321">'HtmlNode.Id.get()' создает исключение с типом 'Exception', данный тип исключения не должен вызываться в свойстве. Если существует вероятность вызова этого экземпляра исключения, используйте исключение другого типа, преобразуйте это свойство в метод или измените его логику так, чтобы она не вызывала исключения.</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="HtmlNodeCollection" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#System.Collections.Generic.IEnumerable`1&lt;HtmlAgilityPack.HtmlNode&gt;.GetEnumerator()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeCollection.cs" Line="148">Запечатайте 'HtmlNodeCollection' (критическое изменение, если ранее данный класс был доставлен), реализуйте метод неявно или реализуйте новый метод, который предоставляет функциональность 'IEnumerable&lt;HtmlNode&gt;.GetEnumerator()' и видим производным классам.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#System.Collections.IEnumerable.GetEnumerator()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeCollection.cs" Line="157">Запечатайте 'HtmlNodeCollection' (критическое изменение, если ранее данный класс был доставлен), реализуйте метод неявно или реализуйте новый метод, который предоставляет функциональность 'IEnumerable.GetEnumerator()' и видим производным классам.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="HtmlNodeNavigator" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor()" Kind="Method" Static="False" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="20">'HtmlNodeNavigator.HtmlNodeNavigator()' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;HtmlNodeNavigator..ctor()&#xD;&#xA;HtmlNodeNavigator.Reset():Void&#xD;&#xA;HtmlNodeNavigator.InternalTrace(Object):Void&#xD;&#xA;Object.GetHashCode():Int32</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(HtmlAgilityPack.HtmlDocument,HtmlAgilityPack.HtmlNode)" Kind="Method" Static="False" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="20">'HtmlNodeNavigator.HtmlNodeNavigator(HtmlDocument, HtmlNode)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;HtmlNodeNavigator..ctor(HtmlDocument, HtmlNode)&#xD;&#xA;HtmlNodeNavigator.InternalTrace(Object):Void&#xD;&#xA;Object.GetHashCode():Int32</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(HtmlAgilityPack.HtmlNodeNavigator)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="20">'HtmlNodeNavigator.HtmlNodeNavigator(HtmlNodeNavigator)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;HtmlNodeNavigator..ctor(HtmlNodeNavigator)&#xD;&#xA;HtmlNodeNavigator.InternalTrace(Object):Void&#xD;&#xA;Object.GetHashCode():Int32</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.IO.Stream)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="20">'HtmlNodeNavigator.HtmlNodeNavigator(Stream)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;HtmlNodeNavigator..ctor(Stream)&#xD;&#xA;HtmlNodeNavigator.Reset():Void&#xD;&#xA;HtmlNodeNavigator.InternalTrace(Object):Void&#xD;&#xA;Object.GetHashCode():Int32</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.IO.Stream,System.Boolean)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="20">'HtmlNodeNavigator.HtmlNodeNavigator(Stream, bool)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;HtmlNodeNavigator..ctor(Stream, Boolean)&#xD;&#xA;HtmlNodeNavigator.Reset():Void&#xD;&#xA;HtmlNodeNavigator.InternalTrace(Object):Void&#xD;&#xA;Object.GetHashCode():Int32</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.IO.Stream,System.Text.Encoding)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="20">'HtmlNodeNavigator.HtmlNodeNavigator(Stream, Encoding)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;HtmlNodeNavigator..ctor(Stream, Encoding)&#xD;&#xA;HtmlNodeNavigator.Reset():Void&#xD;&#xA;HtmlNodeNavigator.InternalTrace(Object):Void&#xD;&#xA;Object.GetHashCode():Int32</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="20">'HtmlNodeNavigator.HtmlNodeNavigator(Stream, Encoding, bool)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;HtmlNodeNavigator..ctor(Stream, Encoding, Boolean)&#xD;&#xA;HtmlNodeNavigator.Reset():Void&#xD;&#xA;HtmlNodeNavigator.InternalTrace(Object):Void&#xD;&#xA;Object.GetHashCode():Int32</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="20">'HtmlNodeNavigator.HtmlNodeNavigator(Stream, Encoding, bool, int)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;HtmlNodeNavigator..ctor(Stream, Encoding, Boolean, Int32)&#xD;&#xA;HtmlNodeNavigator.Reset():Void&#xD;&#xA;HtmlNodeNavigator.InternalTrace(Object):Void&#xD;&#xA;Object.GetHashCode():Int32</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.IO.TextReader)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="20">'HtmlNodeNavigator.HtmlNodeNavigator(TextReader)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;HtmlNodeNavigator..ctor(TextReader)&#xD;&#xA;HtmlNodeNavigator.Reset():Void&#xD;&#xA;HtmlNodeNavigator.InternalTrace(Object):Void&#xD;&#xA;Object.GetHashCode():Int32</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="20">'HtmlNodeNavigator.HtmlNodeNavigator(string)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;HtmlNodeNavigator..ctor(String)&#xD;&#xA;HtmlNodeNavigator.Reset():Void&#xD;&#xA;HtmlNodeNavigator.InternalTrace(Object):Void&#xD;&#xA;Object.GetHashCode():Int32</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.String,System.Boolean)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="20">'HtmlNodeNavigator.HtmlNodeNavigator(string, bool)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;HtmlNodeNavigator..ctor(String, Boolean)&#xD;&#xA;HtmlNodeNavigator.Reset():Void&#xD;&#xA;HtmlNodeNavigator.InternalTrace(Object):Void&#xD;&#xA;Object.GetHashCode():Int32</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.String,System.Text.Encoding)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="20">'HtmlNodeNavigator.HtmlNodeNavigator(string, Encoding)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;HtmlNodeNavigator..ctor(String, Encoding)&#xD;&#xA;HtmlNodeNavigator.Reset():Void&#xD;&#xA;HtmlNodeNavigator.InternalTrace(Object):Void&#xD;&#xA;Object.GetHashCode():Int32</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.String,System.Text.Encoding,System.Boolean)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="20">'HtmlNodeNavigator.HtmlNodeNavigator(string, Encoding, bool)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;HtmlNodeNavigator..ctor(String, Encoding, Boolean)&#xD;&#xA;HtmlNodeNavigator.Reset():Void&#xD;&#xA;HtmlNodeNavigator.InternalTrace(Object):Void&#xD;&#xA;Object.GetHashCode():Int32</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.String,System.Text.Encoding,System.Boolean,System.Int32)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalWarning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="20">'HtmlNodeNavigator.HtmlNodeNavigator(string, Encoding, bool, int)' содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: &#xD;&#xA;&#xD;&#xA;HtmlNodeNavigator..ctor(String, Encoding, Boolean, Int32)&#xD;&#xA;HtmlNodeNavigator.Reset():Void&#xD;&#xA;HtmlNodeNavigator.InternalTrace(Object):Void&#xD;&#xA;Object.GetHashCode():Int32</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#NodeType" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_NodeType()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message TypeName="DoNotRaiseExceptionsInUnexpectedLocations" Category="Microsoft.Design" CheckId="CA1065" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="Breaking">
               <Issue Name="PropertyGetter" Certainty="90" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="346">'HtmlNodeNavigator.NodeType.get()' создает исключение с типом 'NotImplementedException', данный тип исключения не должен вызываться в свойстве. Если существует вероятность вызова этого экземпляра исключения, используйте исключение другого типа, преобразуйте это свойство в метод или измените его логику так, чтобы она не вызывала исключения.</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#Value" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_Value()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message TypeName="DoNotRaiseExceptionsInUnexpectedLocations" Category="Microsoft.Design" CheckId="CA1065" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="Breaking">
               <Issue Name="PropertyGetter" Certainty="90" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlNodeNavigator.cs" Line="398">'HtmlNodeNavigator.Value.get()' создает исключение с типом 'NotImplementedException', данный тип исключения не должен вызываться в свойстве. Если существует вероятность вызова этого экземпляра исключения, используйте исключение другого типа, преобразуйте это свойство в метод или измените его логику так, чтобы она не вызывала исключения.</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="HtmlWeb" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#SaveStream(System.IO.Stream,System.String,System.DateTime,System.Int32)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="Не ликвидировать объекты несколько раз" Category="Microsoft.Usage" CheckId="CA2202" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="d:\Cloud@Mail.Ru\isbk-src\src\Modules\modMHT\HAP" File="HtmlWeb.cs" Line="1339">Объект "'fs'" можно удалять более одного раза в методе 'HtmlWeb.SaveStream(Stream, string, DateTime, int)'. Чтобы избежать исключения System.ObjectDisposedException, следует вызывать метод "Dispose" для объекта только один раз.: Lines: 1339</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="HtmlWebException" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="MarkISerializableTypesWithSerializable" Category="Microsoft.Usage" CheckId="CA2237" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
           <Issue Certainty="95" Level="Error">Добавьте [Serializable] к 'HtmlWebException', так как этот тип реализует ISerializable.</Issue>
          </Message>
         </Messages>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="WNetConnection">
       <Types>
        <Type Name="NetworkConnection" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#WNetAddConnection2(WNetConnection.NetResource,System.String,System.String,System.UInt32)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">Так как метод является методом P/Invoke, 'NetworkConnection.WNetAddConnection2(NetResource, string, string, uint)' должен быть определен в классе с именем NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</Issue>
            </Message>
            <Message Id="1" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать параметр 'password' как Юникод, установив значение CharSet.Unicode для DllImport.CharSet, либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо упаковать и передать эту строку как ANSI или зависящую от системы, укажите MarshalAs явно и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</Issue>
            </Message>
            <Message Id="2" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать параметр 'username' как Юникод, установив значение CharSet.Unicode для DllImport.CharSet, либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо упаковать и передать эту строку как ANSI или зависящую от системы, укажите MarshalAs явно и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</Issue>
            </Message>
            <Message Id="NetResource.Comment" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Name="FieldImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать поле 'NetResource.Comment' в кодировке Юникод, установив значение StructLayout.CharSet в 'NetResource' равным CharSet.Unicode, либо явно определив поле как UnmanagedType.LPWStr. При необходимости маршалировать эту строку как ANSI или зависящую от системы, явно укажите MarshalAs, используйте атрибут BestFitMapping для выключения сопоставления путем автоматического подбора, а также включите параметр ThrowOnUnmappableChar.</Issue>
            </Message>
            <Message Id="NetResource.LocalName" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Name="FieldImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать поле 'NetResource.LocalName' в кодировке Юникод, установив значение StructLayout.CharSet в 'NetResource' равным CharSet.Unicode, либо явно определив поле как UnmanagedType.LPWStr. При необходимости маршалировать эту строку как ANSI или зависящую от системы, явно укажите MarshalAs, используйте атрибут BestFitMapping для выключения сопоставления путем автоматического подбора, а также включите параметр ThrowOnUnmappableChar.</Issue>
            </Message>
            <Message Id="NetResource.Provider" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Name="FieldImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать поле 'NetResource.Provider' в кодировке Юникод, установив значение StructLayout.CharSet в 'NetResource' равным CharSet.Unicode, либо явно определив поле как UnmanagedType.LPWStr. При необходимости маршалировать эту строку как ANSI или зависящую от системы, явно укажите MarshalAs, используйте атрибут BestFitMapping для выключения сопоставления путем автоматического подбора, а также включите параметр ThrowOnUnmappableChar.</Issue>
            </Message>
            <Message Id="NetResource.RemoteName" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Name="FieldImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать поле 'NetResource.RemoteName' в кодировке Юникод, установив значение StructLayout.CharSet в 'NetResource' равным CharSet.Unicode, либо явно определив поле как UnmanagedType.LPWStr. При необходимости маршалировать эту строку как ANSI или зависящую от системы, явно укажите MarshalAs, используйте атрибут BestFitMapping для выключения сопоставления путем автоматического подбора, а также включите параметр ThrowOnUnmappableChar.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WNetCancelConnection2(System.String,System.Int32,System.Boolean)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">Так как метод является методом P/Invoke, 'NetworkConnection.WNetCancelConnection2(string, int, bool)' должен быть определен в классе с именем NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</Issue>
            </Message>
            <Message Id="0" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2014-05-27 01:56:30Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">Чтобы уменьшить угрозу безопасности, следует маршалировать параметр 'name' как Юникод, установив значение CharSet.Unicode для DllImport.CharSet, либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо упаковать и передать эту строку как ANSI или зависящую от системы, укажите MarshalAs явно и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
     </Namespaces>
    </Module>
   </Modules>
  </Target>
 </Targets>
 <Rules>
  <Rule TypeName="DoNotCallOverridableMethodsInConstructors" Category="Microsoft.Usage" CheckId="CA2214">
   <Name>Не вызывайте переопределяемые методы в конструкторах</Name>
   <Description>Виртуальные методы, определенные в классе, не следует вызывать из конструкторов. Если производный класс переопределил метод, будет вызвана версия производного класса (до вызова конструктора производного класса).</Description>
   <Resolution Name="Default">{0} содержит цепочку вызовов, которая приводит к вызову виртуального метода, определенного классом. Просмотрите следующий стек вызовов для обнаружения непреднамеренных последствий: {1}</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182331.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalWarning</MessageLevel>
   <File Name="usagerules.dll" Version="12.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotRaiseExceptionsInUnexpectedLocations" Category="Microsoft.Design" CheckId="CA1065">
   <Name>Не вызывайте исключения в непредвиденных местах</Name>
   <Description>Не следует явно вызывать исключения из неожиданных мест расположения. Существует ряд методов, например, Equals и GetHashCode, пользователи которых не ожидают вызова исключений. В связи с этим вызовы этих методов редко заключены в блоки try catch.</Description>
   <Resolution Name="PropertyGetter">{0} создает исключение с типом {1}, данный тип исключения не должен вызываться в свойстве. Если существует вероятность вызова этого экземпляра исключения, используйте исключение другого типа, преобразуйте это свойство в метод или измените его логику так, чтобы она не вызывала исключения.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/bb386039.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">Error, Warning</MessageLevel>
   <File Name="designrules.dll" Version="12.0.0.0" />
  </Rule>
  <Rule TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033">
   <Name>Методы интерфейса должны быть доступны для вызова дочерним типам</Name>
   <Description>Явные реализации методов определены с режимом доступа private. Классы, производные от классов с явной реализацией методов и выбравшие их повторное объявление на своем уровне, не смогут вызывать реализации базового класса, если базовый класс не предоставит альтернативный метод с соответствующим режимом доступа. В случае переопределения метода базового класса, который был скрыт, благодаря явной реализации интерфейса, производный класс, чтобы вызвать реализацию базового класса, должен выполнить приведение базового указателя к соответствующему интерфейсу. Однако при вызове при помощи данной ссылки фактически будет вызываться реализация производного класса, что приведет к рекурсии и, в конце концов, к переполнению стека.</Description>
   <Resolution Name="Default">Запечатайте {0} (критическое изменение, если ранее данный класс был доставлен), реализуйте метод неявно или реализуйте новый метод, который предоставляет функциональность {1} и видим производным классам.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182153.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="12.0.0.0" />
  </Rule>
  <Rule TypeName="MarkISerializableTypesWithSerializable" Category="Microsoft.Usage" CheckId="CA2237">
   <Name>Пометьте типы ISerializable атрибутом SerializableAttribute</Name>
   <Description>Интерфейс System.Runtime.Serialization.ISerializable дает возможность типу настраивать свою сериализацию, в то время как атрибут Serializable дает возможность исполняющей среде опознавать этот тип как сериализуемый.</Description>
   <Resolution Name="Default">Добавьте [Serializable] к {0}, так как этот тип реализует ISerializable.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182350.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="usagerules.dll" Version="12.0.0.0" />
  </Rule>
  <Rule TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060">
   <Name>Переместите методы P/Invoke в класс NativeMethods</Name>
   <Description>В этом типе содержатся члены с атрибутом DllImport. Члены с атрибутом DllImport должны содержаться в классах с именем NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</Description>
   <Resolution Name="Default">Так как метод является методом P/Invoke, {0} должен быть определен в классе с именем NativeMethods, SafeNativeMethods или UnsafeNativeMethods.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182161.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalWarning</MessageLevel>
   <File Name="designrules.dll" Version="12.0.0.0" />
  </Rule>
  <Rule TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101">
   <Name>Укажите тип маршалинга для строковых аргументов P/Invoke</Name>
   <Description>При маршалинге строк в формате ANSI (или как Auto в Win9x) некоторые знаки могут быть изменены. Если включено сопоставление путем автоматического подбора, строки, которые отображаются в формате Юникод по-другому, будут маршалированы в идентичные ANSI-строки, что может привести к неверным решениям по обеспечению безопасности. Отключение сопоставления путем автоматического подбора уменьшит возможность этой угрозы, так как все знаки, не имеющие эквивалента, будут заменены знаком "?". Также следует отметить, что CharSet.Ansi является настройкой по умолчанию для маршалинга всех строк. Маршалинг в формате Юникод следует указывать явно, либо как значение CharSet в DllImport или StructLayout, либо как атрибут MarshalAs с типом Unicode (или зависящим от системы) UnmanagedType.</Description>
   <Resolution Name="FieldImplicitAnsi">Чтобы уменьшить угрозу безопасности, следует маршалировать поле {0} в кодировке Юникод, установив значение StructLayout.CharSet в {1} равным CharSet.Unicode, либо явно определив поле как UnmanagedType.LPWStr. При необходимости маршалировать эту строку как ANSI или зависящую от системы, явно укажите MarshalAs, используйте атрибут BestFitMapping для выключения сопоставления путем автоматического подбора, а также включите параметр ThrowOnUnmappableChar.</Resolution>
   <Resolution Name="ParameterImplicitAnsi">Чтобы уменьшить угрозу безопасности, следует маршалировать параметр {0} как Юникод, установив значение CharSet.Unicode для DllImport.CharSet, либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо упаковать и передать эту строку как ANSI или зависящую от системы, укажите MarshalAs явно и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182319.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Error</MessageLevel>
   <File Name="globalizationrules.dll" Version="12.0.0.0" />
  </Rule>
  <Rule TypeName="Не ликвидировать объекты несколько раз" Category="Microsoft.Usage" CheckId="CA2202">
   <Name>Не ликвидировать объекты несколько раз</Name>
   <Description>Правильно реализованный метод Dispose может вызываться неоднократно без создания исключения. Однако такой гарантии нет, и чтобы предотвратить создание System.ObjectDisposedException, не следует вызывать метод Dispose для объекта более одного раза.</Description>
   <Resolution Name="Default">Объект "{0}" можно удалять более одного раза в методе {1}. Чтобы избежать исключения System.ObjectDisposedException, следует вызывать метод "Dispose" для объекта только один раз.: Lines: 1339</Resolution>
   <Owner>RuleOwner</Owner>
   <Url>http://msdn.microsoft.com/library/ms182334.aspx</Url>
   <Email />
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="dataflowrules.dll" Version="12.0.0.0" />
  </Rule>
 </Rules>
 <Localized>
  <String Key="Category">Категория</String>
  <String Key="Certainty">Достоверность</String>
  <String Key="CollapseAll">Свернуть все</String>
  <String Key="CheckId">ИД проверки</String>
  <String Key="Error">Ошибка</String>
  <String Key="Errors">ошибки</String>
  <String Key="ExpandAll">Развернуть все</String>
  <String Key="Help">Справка</String>
  <String Key="Line">Строка</String>
  <String Key="Messages">сообщения</String>
  <String Key="LocationNotStoredInPdb">[расположение не сохранено в PDB]</String>
  <String Key="Project">Проект</String>
  <String Key="Resolution">Разрешение</String>
  <String Key="Rule">Правило</String>
  <String Key="RuleFile">Файл правил</String>
  <String Key="RuleDescription">Описание правила</String>
  <String Key="Source">Источник</String>
  <String Key="Status">Состояние</String>
  <String Key="Target">Цель</String>
  <String Key="Warning">Предупреждение</String>
  <String Key="Warnings">предупреждения</String>
  <String Key="ReportTitle">Отчет по анализу кода</String>
 </Localized>
</FxCopReport>
